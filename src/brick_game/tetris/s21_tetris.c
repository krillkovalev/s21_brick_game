#include "s21_tetris.h"
#define ROWS 20
#define COLUMNS 10

void moveDown(char(*field)[COLUMNS], char (*shape)[2], int y, int x);

int main(void) {

   // for (int i = 0; i < COLUMNS; i++) {
   //    for (int j = 0; j < ROWS; j++) {
   //       printf("0");
   //    }
   // printf("\n");
   // }
   // printf("\n");
   char field[ROWS][COLUMNS] = {
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
                        {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0'}
};

//    for (int i = 0; i < ROWS; i++) {
//       for (int j = 0; j < COLUMNS; j++) {
//          printf("%c", field[i][j]);
//       }
//    printf("\n");
//    }
//    printf("\n");
   int x = 0, y = 3;
   char shape[2][2] = {{'1', '1'}, {'1', '1'}};
   moveDown(field, shape, x, y);
   for (int i = 0; i < ROWS; i++) {
      for (int j = 0; j < COLUMNS; j++) {
         printf("%c ", field[i][j]);
      }
      printf("\n");
   }
   printf("\n");
//    for (int i = 0; i < 2; i++) {
//       for (int j = 0; j < 2; j++) {
//          printf("%d ", shape[i][j]);
//       }
//    printf("\n");
//    }
//    printf("\n");   
//    int shape_1[4][4] = {{0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}};
   
//    for (int i = 0; i < 4; i++) {
//       for (int j = 0; j < 4; j++) {
//          printf("%d ", shape_1[i][j]);
//       }
//    printf("\n");
//    }


}

// void field_current(int arr[10][20])

void moveDown(char(*field)[COLUMNS], char (*shape)[2], int y, int x) {
    // Проверяем, не достигла ли фигура нижней границы игрового поля
    if (y + 4 > ROWS) {
        return; // Фигура достигла нижней границы, сдвиг невозможен
    }

    // Сдвигаем фигуру вниз
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            if (shape[i][j] == '1') {
                // Проверяем, не столкнулась ли фигура с другими блоками
                if (field[y + i + 1][x + j] == '1') {
                    return; // Столкновение, сдвиг невозможен
                }
                // Сдвигаем блок вниз
                field[y + i + 1][x + j] = '1';
            }
        }
    }

    // Очищаем предыдущую позицию фигуры
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            if (shape[i][j] == '1') {
                field[y + i][x + j] = '1';
            }
        }
    }
}
